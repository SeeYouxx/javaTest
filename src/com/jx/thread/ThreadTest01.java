package com.jx.thread;

/**
 * @program: java
 * @description:                进程：是一个应用程序（一个进程就是一个软件）
 *                              线程：是一个进程中的执行场景/执行单元
 *                              一个进程可以启动多个线程
 *
 *                              对于java程序来说，当在DOS命令窗口中输入：
 *                              java HelloWorld 回车之后
 *                              会先启动JVM，而JVM就是一个进程
 *                              JVM在启动一个主线程就调用main方法
 *                              同时在启动一个垃圾回收器负责看护，回收垃圾
 *                              最起码，现在的java程序中至少有两个线程并发，一个是垃圾回收线程，一个是执行main方法的主线程
 *
 *                              进程和线程是什么关系：
 *
 *                                     进程之间内存不共享
 *
 *                                     线程之间：    堆内存和方法区内存共享
 *                                                  但是栈内存独立，一个线程一个栈
 *
 *                             多线程并发可以提高效率
 *
 *
 *                             使用多线程机制，线程main结束 ，而支栈可能继续弹栈压栈
 *
 *
 *                             真正的多线程并发
 *                                   t1线程执行t1
 *                                   t2线程执行t2
 *                                   t1不会影响t2，t2不会影响t1 这叫做多线程并发\
 *
 *
 *
 *                           实现线程的方式：
 *                               1：编写一个类，直接继承java.lang.Thread,重写run方法。
 *                                    main方法里直接new thread对象
 *                                    调用start方法
 *
 *                              2：编写一个类实现java.lang,Runnable接口
 *                                    定义一个可运行的类
 *                                    public  class MyRunnable implements Runnable {
 *
 *                                        public void run(){
 *
 *                                        }
 *                                    }
 *                                    创建线程对象
 *                                      Thread t = new Thread(new MyRunnable())
 *                                    启动线程
 *                                       t.start();
 *
 *
 *                                       synchronized有三种写法：
 *
 *                                             1.同步代码块
 *                                                 灵活
 *                                              synchronized（线程对象）{
 *                                                   同步代码块
 *                                             }
 *
 *                                              2.在实例方法上使用synchronized
 *                                               表示共享对象一定是this
 *                                               并且同步代码块是整个方法
 *
 *                                               3.在静态方法上使用synchronized
 *                                               表示找类锁
 *                                               类锁永远只有一把
 *                                               就算创建了100个对象，那类锁也只有一把
 *
 *                                     对象锁：一个对象一把锁，100个对象100把锁
 *                                     类锁：100个对象，也可能只有一把类锁
 *
 *
 *                                  synchronized会让程序的执行效率降低，用户体验不好，
 *                                  系统的用户吞吐量降低，用户体验差。在不得已的情况下
 *                                  再选择线程同步机制
 *
 *                                  第一种方案：尽量使用局部变量代替"实例变量和静态变量"
 *
 *                                  第二种方案：如果必须是实例变量，那么可以考虑创建多个对象
 *                                  这样实例变量的内存就不共享了。（一个线程对应1个对象，100个
 *                                  线程对应100个对象，对象不共享，就没有数据安全问题了）
 *
 *                                  第三种方案：如果不能使用局部变量，对象也不能创建多个，这个
 *                                  时候就只能选择synchronized了，线程同步机制
 *
 *
 *
 *
 *                        1.守护线程
 *                           java语言中线程分为两大类：
 *                                一类是：用户线程
 *                                一类是：守护线程（后台线程）
 *                                其中具有代表性的就是：垃圾回收线程（守护线程）
 *
 *                           守护线程的特点：
 *                                 一般守护线程是一个死循环，所有的用户线程只要结束
 *                               守护线程自动结束
 *
 *                               注意：主线程main方法就是一个用户线程
 *
 *                               守护线程用在什么地方？
 *                                   每天00：00的时候系统数据备份
 *                                   这个需要使用到定时器，并且我们可以将定时器设置为守护线程。
 *                                   一直在那里看着，没到00：00的时候就备份一次，所有的用户线程
 *                                   如果结束了，守护线程自动退出。没有必要进行数据备份了
 *
 *
 *
 *                        2.定时器：
 *                              间隔特定的时间，执行特定的程序
 *
 *                                  每周要进行银行账户的总账操作
 *                                  每天要进行数据的备份
 *
 *
 *                                  在实际的开发中，每隔多久执行一段特定的程序，这种需求是很常见的。
 *                                  那么在java中其实可以采用多种方式实现：
 *
 *                                            可以使用sleep方法，睡眠，设置睡眠时间，没到这个时间点醒来，执行任务
 *                                          这种方式是最原始的定时器。（比较low）
 *
 *                                            在java的类库中已经写好了一个定时器：java.util.Timer.可以直接拿来用。
 *                                          不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持
 *                                          定时任务的。
 *
 *                                            在实际开发中，目前使用较多的是Spring框架中提供的SpringTask框架，这个
 *                                          框架只要进行简单的配置，就可以完成定时器的任务。
 *
 *
 *
 *                        3.实现线程的第三种方式：FutureTask方式，实现Callable接口
 *
 *                                       这种方式实现的线程可以获取线程的返回值
 *                                       之前讲解的两种方式是无法获取线程返回值的，因为run方法返回void。
 *
 *                                     思考：
 *                                           系统委派一个线程去执行一个任务，该线程执行完任务之后，可能
 *                                           会有一个执行结果，我们怎么拿到这个执行结果呢？
 *                                                使用第三种方式：实现Callable接口方式
 *
 *
 *                        4.关于Object类中的wait和notify方法 （生产者和消费者模式）
 *                                      wait 和 notify是任何java对象都有的方法 ，因为这个两个方式是object类中自带的
 *                                      wait方法和notify方法不是通过线程对象调用
 *
 *                                      wait（）方法的作用
 *                                           Object o = new Object();
 *                                           o.wait();
 *                                          让正在o对象上活动的线程进入等待状态，无期限等待，
 *                                          直到被唤醒为止。
 *                                           o.wait();方法的调用,会让"当前线程(正在o对象上活动的线程)"进入等待状态
 *
 *                                      notify()方法作用
 *                                          Object o = new Object();
 *                                          o.notify();
 *
 *                                          唤醒正在o对象上等待的线程.
 *
 *                                          还有一个notifyAll()方法:
 *                                               这个方法是唤醒o对象上处于等待的所有线程
 *
 *
 *                         生产者和消费者模式是为了专门解决某个特定需求的
 *
 *                             一个线程负责生产 Producer
 *                             一个线程负责消费 Consumer
 *                                 仓库是多线程共享,所以需要考虑仓库的线程安全的问题
 *
 *                                 仓库对象最终调用wait和notify方法
 *
 *                                 注意:wait方法和notify方法建立在synchronized线程同步的基础之上
 *
 *                          重点: o.wait()方法会让正在o对象上活动的当前线程进入等待状态,并且释放之前占有的o对象的锁
 *                                o.notify()方法只会通知,不会释放之前占有的o对象的锁
 *
 * @author:
 * @create: 2020-11-23 11:48
 */
public class ThreadTest01 {
    public static void main(String[] args) {
        //主线程
        //新建一个分支线程对象
        Mythread mythread =new Mythread();
        //start()方法 ：启动一个分支线程，在jvm中开辟一个新的栈空间，这段代码任务完成之后，瞬间就结束了
        //这段代码的任务只是为了开启一个新的栈空间，只要新的栈空间开辟出来，start（）方法就结束了，线程就启动成功了
        //启动成功的线程会自动调用run方法，并且run方法在分支线的底部（压栈）
        //run方法在分支栈的栈底部，main方法在主栈的栈底部，run和main是平级的
        mythread.start();

        for (int i = 0 ; i < 1000; i++){
            System.out.println("主线程——>"+i);
        }


    }


}


class Mythread extends  Thread {

    @Override
    public void  run(){
        //编写程序，这段程序运行在分支线程中（分支线）
        for (int i = 0 ; i < 1000; i++){
            System.out.println("分支线程——>"+i);
        }
    }

}